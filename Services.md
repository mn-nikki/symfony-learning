Сервисный слой как абстракция. Применимость SOLID к сервисному слою
===================================================================

Определение [SOLID по Википедии](https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))


![Service layer](http://design-pattern.ru/i/service-layer.gif)

В общем понимании, сервисный слой - это абстракция, определяющая границу между приложением и слоем сервисов, который 
образует набор доступных операций и управляет ответом приложения в каждой операции. 

На изображении отлично видно расположение сервисного слоя в общей архитектуре приложения.

В нашем примере, `Entity` - это **Domain model**, а `Repository` - **Data Source Layer**.

Но будет не правильно помещать логику взаимодействия наших Entity в них самих. И вы это уже видели на примере. 
Для того, что бы взаимодействовать с данными в нашем приложении был создан [PizzaManager](src/Service/PizzaManager.php). 

Это сервис, который отвечает за взаимодействие с нашими сущностями. Давайте детальней рассмотрим его заявленную функциональность, описанную в 
[PizzaManagerInterface](src/Service/PizzaManagerInterface.php)
- **getRepository()** - получение репозитория для прямого доступа к данным
- **get()** - получение конкретной сущности по id
- **findBy()** - поиск сущностей по определенному свойству
- **update()** - обновление сущности
- **delete()** - удаление сущности
- **store()** - добавление сущности 

Все эти методы так или иначе реализуют `CRUD`. Т.е. наш сервис имеет четко ограниченную функциональность. 

Итого, мы имеем сервис, который обслуживает CRUD операции для нашей сущности, при этом он соблюдает SOLID
- **S** - мы имеем сервис с ограниченной ответственностью, и только одной причиной для его изменения
- **O** - с этим сложнее, но стоит отметить, что извне нельзя изменить состояние его внутренних объектов, и при возникновении 
необходимости в модификации сервиса, у нас есть интерфейс, который декларирует нам, что он должен решать.
- **L** - Данны принцип должен соблюдаться при дальнейшей разработке
- **I** - Сервис слишком мал, что бы делить его на подсервисы. Так же он выполняет только одну задачу, описанную в единственном интерфейсе
- **D** - Хорошо заметно в конструкторе, где нет заявления на конкретные объекты, а лишь на представляющие их интерфейсы, а так же в методе
getRepository, где по факту, мы возвращаем конкретный репозиторий, но заявляем общий класс.

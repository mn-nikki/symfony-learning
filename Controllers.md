Контроллеры. Роутинг
====================

[Статья официальной документации](https://symfony.com/doc/current/routing.html)

Поскольку Symfony-приложение имеет единую точку входа для любых запросов, все маршруты (роуты) внутри приложения обрабатываются программно. Это обеспечивает комплект классов, отвечающий за разбор пути и набора парамеров, пришедших с запросом, и сопоставление действий контроллеров с этими путями.

На старте приложения существует предопределенная конфигурация роутинга (файл `config/routes/annotations.yaml`):

```yaml
controllers:
  resource: ../../src/Controller/
  type: annotation

kernel:
  resource: ../../src/Kernel.php
  type: annotation
```

Эта конфигурация говорит фреймворку смотреть на все классы в каталогах и подкаталогах `src/Controller/` и класс `Kernel`, читать оттуда аннотации и пытаться определить маршрут исходя из этих аннотаций.

Чуть подробнее про аннотации
----------------------------

В некоторых языках аннотации существуют как часть языка, в php8 это будет так же, но пока аннотации в php реализуются с помощью PHPDoc-блоков и пакета `doctrine/annotations`. Этот пакет разбирает все PHPDoc-блоки класса, выделяет из них комментарии, начинающиеся с `@` и пытается сопоставить существующие (загруженные) классы аннотаций, соответствующие этим комментариям.

Это довольно затратная операция, и это накладивает некоторые ограничения (к примеру, простой комментарий, начинающися с `@` будет воспринят, как аннотация, и вызовет ошибку, поскольку класса, соответствующего этой аннотации, скорее всего не существует), но является очень удобным и действенным механизмом.

Отладка (дебаг)
---------------

Для того, чтобы посмотреть, какие маршруты есть в приложении (а так же подробную информацию для определенного маршрута) существует встроенная команда `debug:router`

```shell
bin/console debug:router

-------------------------- -------- -------- ------ -----------------------------------
  Name                       Method   Scheme   Host   Path
 -------------------------- -------- -------- ------ -----------------------------------
  _preview_error             ANY      ANY      ANY    /_error/{code}.{_format}
  _wdt                       ANY      ANY      ANY    /_wdt/{token}
  _profiler_home             ANY      ANY      ANY    /_profiler/
  _profiler_search           ANY      ANY      ANY    /_profiler/search
  _profiler_search_bar       ANY      ANY      ANY    /_profiler/search_bar
  _profiler_phpinfo          ANY      ANY      ANY    /_profiler/phpinfo
  _profiler_search_results   ANY      ANY      ANY    /_profiler/{token}/search/results
  _profiler_open_file        ANY      ANY      ANY    /_profiler/open
  _profiler                  ANY      ANY      ANY    /_profiler/{token}
  _profiler_router           ANY      ANY      ANY    /_profiler/{token}/router
  _profiler_exception        ANY      ANY      ANY    /_profiler/{token}/exception
  _profiler_exception_css    ANY      ANY      ANY    /_profiler/{token}/exception.css
 -------------------------- -------- -------- ------ -----------------------------------
```

Правила роутинга и параметры
----------------------------

**Не забудьте импортировать класс аннотации роутинга перед тем, как его использовать!**     
```php
use Symfony\Component\Routing\Annotation\Route;
```

В простейшем случае правило роутинга задаётся аннотацией `@Route` с параметром `path`. Следует помнить, что к этому роуту в дальнейшем возможно обращение изнутри приложения, поэтому стоит сразу дать ему параметр `name`, чтобы потом не возвращаться.

Итак, простейший случай роутинга, определенный в аннотации, действие контроллера будет получать запросы по URL-у `/rules`

```php
    /**
     * @Route("/rules", name="rules_index")
     *
     * @return Response
     */
    public function rules(): Response
    {
        return $this->render('rules/index.html.twig', [
            'rules' => self::$rules,
        ]);
    }
```

Аннотации использовать необязательно: конфигурация маршрутов может храниться в YAML/XML/PHP-файлах. К примеру, в файле `config/routes.yaml` сконфигурирован маршрут `/rules/yaml`:

```yaml
yaml_rules_index:
  path: /rules/yaml
  controller: App\Controller\RoutingRulesController:yamlRules
```

Тот же эффект от xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<routes xmlns="http://symfony.com/schema/routing" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/routing https://symfony.com/schema/routing/routing-1.0.xsd">

    <route id="xml_rules_index" path="/rules/xml"
           controller="App\Controller\RoutingRulesController:yamlRules"/>
</routes>
```

Когда мы сконфигурировали два наших маршрута, команда `debug:router` их покажет:

```shell
bin/console debug:router

 -------------------------- -------- -------- ------ -----------------------------------
  Name                       Method   Scheme   Host   Path
 -------------------------- -------- -------- ------ -----------------------------------
  ... ... ...
  rules_index                ANY      ANY      ANY    /rules
  yaml_rules_index           ANY      ANY      ANY    /rules/yaml
 -------------------------- -------- -------- ------ -----------------------------------
```

И мы можем посмотреть, какой контроллер и его метод обрабатывают запрос

```shell
bin/console debug:router rules_index

+--------------+-------------------------------------------------------------+
| Property     | Value                                                       |
+--------------+-------------------------------------------------------------+
| Route Name   | rules_index                                                 |
| Path         | /rules                                                      |
| Path Regex   | {^/rules$}sDu                                               |
| Host         | ANY                                                         |
| Host Regex   |                                                             |
| Scheme       | ANY                                                         |
| Method       | ANY                                                         |
| Requirements | NO CUSTOM                                                   |
| Class        | Symfony\Component\Routing\Route                             |
| Defaults     | _controller: App\Controller\RoutingRulesController::rules() |
| Options      | compiler_class: Symfony\Component\Routing\RouteCompiler     |
|              | utf8: true                                                  |
+--------------+-------------------------------------------------------------+
```

### Параметры запроса

Общей практикой является определение роутов с динамическими частями. К примеру, новости или записи блога, получение записи по её идентификатору и так далее. В Symfony предусмотрен механизм для реализации такого поведения

К примеру, такая аннотация

```
@Route("/rule/{slug}", name="show_rule")
```

говорит движку, что в части маршрута `slug` будет содержаться некая строка. При этом метод контроллера получает переменную, равную содержимому этой части, с названием равным её названию. То есть в данном случае будет переменная `$slug` и та строка, что мы туда передадим.

При этом маршруты могут содержать переменные части в любом месте описания. К примеру:

```
/news/about-{category}/page/{pageNumber}
```

### Валидация параметров

Когда параметры роута должны быть определенного типа (к примеру, существует маршрут `news/{page}`, который отображает список новостей по страницам, и маршрут `news/{slug}`) их следует проверить. Проверки параметров осуществляются в тех же аннотациях:

```
@Route("/news/{page}", name="news_list", requirements={"page"="\d+"})
```

`\d+` — регулярное выражение, которое допускает только цифры.

То же регулярное выражение срабатывает и при таких условиях:

```
@Route("/news/page-{page}", name="news_list", requirements={"page"="\d+"})
```

### Необязательные параметры

В предыдущем случае номер страницы является обязательным параметром, и роут `/news/1` сработает, а `/news` — нет. Это не всегда удобно, и на такой случай как раз предусмотрены необязательные параметры. Достаточно объявить в методе контроллера значение переменной по-умолчанию:

```
@Route("/news/{page}", name="news_list", requirements={"page"="\d+"})
public function newsList(string $page = 1)
```

В этом случае маршрут `/news` будет вести на первую страницу.

Если есть необходимоить подставить номер страницы в URL, даже если он не указан, можно использовать запись `/news/{!page}` (восклицательный знак перед параметром) или `/news/{page<\d+>?1}`.

Если параметр может быть `null`, нужно добавить вопросительный знак после определения: `/news/{page?}`

### Проверка http-методов

Действие контроллера, которое должно отвечать на GET и HEAD запросы:

```
@Route("/news/{page<\d+>?1}", name="news_list", methods={"GET","HEAD"})
```

Post-запрос к адресу `/news/1` вернется с ответом 404. И наоборот, те методы контроллеров, которые должны принимать только POST-запросы, будут отвечать 404 если на их адреса прислать GET. Например, перейти браузером.

Очень часто возникает вопрос: как быть, если роут должен ловить не просто слово, а что-то, похожее на путь? К примеру, вы отдаёте картинку, и сама эта картинка в абстракции ФС имеет некий путь, который вы и передаёте в запросе? То есть получится что-то вроде конфигурации роута `/download/{image}`, но в `{image}` может быть `big/animals/cat.jpg`?

Здесь всё просто и довольно разумно — нужно определить регулярное выражение, под которое попадёт этот путь. Например

```
@Route("/download/{image}", name="image", requirements={"image"=".+"})
```

### Конвертация параметров

Symfony имеет некоторые встроенные возможности для конвертации параметра в объект. К примеру, вот такая конструкция

```php
namespace App\Controller;

use App\Entity\News;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class NewsController extends AbstractController
{
    /**
     * @Route("/news/{slug}", name="blog_show")
     */
    public function show(News $newsItem): Response
    {
        
    }
}
```

будет магическим образом работать. Конвертер сделает запрос к БД и будет искать сущность класса `News` по атрибуту `slug`. 

Такие конвертеры можно делать самому, то есть любой роут может получить тот объект, который вы планируете ему отдать, сформированный из запроса с участием любых сервисов вашего приложения.

Собственная реализация загрузки роутов
--------------------------------------

Перед вами может стоять задача создать, скажем, систему управления контентом, где администратор создаёт пункты меню и адреса для них. При этом может быть реализована какая-то собственная логика, которая не вполне подходит под стандартный механизм роутинга.

Для этого существует возможность создавать собственные лоадеры — это сервисы, которые расширяют абстрактный `Symfony\Component\Config\Loader\Loader` и добавляют к запросам экстра-параметры — `_controller` и другие, которые потом позволяют ядру определить, куда именно этот запрос отправить. 

Генерация URL-ов
----------------

За генерацию URL-ов внутри приложения отвечает `Symfony\Component\Routing\Generator\UrlGeneratorInterface`. Есть сокращенный метод обращения к нему изнутри контроллера (`$this->generateUrl('route_name');`) и из twig-шаблонов (`path('route_name')`).


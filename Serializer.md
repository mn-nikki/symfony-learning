Symfony Serializer 
=================

> сериализация, нормализация-денормализация, настройка, использование и расширение

Статьи официальной документации: [устройство и принципы работы](https://symfony.com/doc/current/components/serializer.html), [использование внутри фреймворка](https://symfony.com/doc/current/serializer.html)

Сериализация объектов (форматирование объекта в строку) и их **де**сериализация (преобразование строки с данными в объект) — главная задача при построении API и сервисов, которые обмениваются данными через внешние каналы.

Форматы данных для обмена
-------------------------

Каким образом бэкенд обменивается данными с внешними сервисами (мобильными приложениями, другими бэкенд-сервисами, js-приложениями для фронтенда) — вопрос договоренностей. В принципе сериализовать данные можно в любой формат, обладающий достаточной для отображения данных структурой — хоть в `csv`, никто не запретит! Официальная документация приводит в пример `json`, `XML`, `csv` и `yaml`, и для всех них существуют встроенные нормализаторы и декодеры. На текущий момент наиболее распространенным является `json` (JavaScript Object Notation), что логично — это текст, который при необходимости несложно прочитать человеку, он обладает всеми необходимыми возможностями для организации отображения вложенных объектов и свойств объектов.

Следует сразу заметить, что простого преобразования свойств объекта в `json`-поля **недостаточно**. Вам обязательно потребуются какие-то метаданные: тип объекта, связанные с ним сущности, в случае списков — количество элементов, ссылка на следующую страницу и так далее. Всё это (включая договоренности об именовании в высокоуровневой структуре объекта) реализовано в нескольких стандартах, и использование любого из стандартов поможет избежать большинства проблем и недопониманий в процессе разработки.

### Стандарты форматирования JSON-данных

- [JSON-LD (Linked Data)](https://json-ld.org)
- [JSON:API](https://jsonapi.org)
- [HAL - Hypertext Application Language](http://stateless.co/hal_specification.html)

Как можно заметить, эти стандарты различаются практически во всём, но обладают одним несомненным общим признаком: они предлагают **формат представления данных**, который будет использоваться для обмена. Этот формат включает в себя определенные имена полей для хранения отношений объекта, ссылок на объект, ссылок на страницы списка, метаданных объекта или списка и непосредственно данных объекта. 

Если вы разрабатываете API, стоит с самого начала определить, с каким форматом вы работаете, и по возможности избегать изобретения собственных форматов и стандартов передачи данных.

Использование сериализатора внутри Symfony-framework
----------------------------------------------------

Как обычно, нужно поставить пакеты:

```shell
composer require symfony/serializer-pack sensio/framework-extra-bundle
```

- `symfony/serializer-pack` включает в себя непосредственно сериализатор, [PropertyAccess](https://symfony.com/doc/current/components/property_access.html) и [PropertyInfo](https://symfony.com/doc/current/components/property_info.html) компоненты, которые используются для доступа к свойствам классов (и свойствам этих свойств) различными способами;
- `sensio/framework-extra-bundle` — расширение Symfony-framework, функциональность которого постепенно переезжает в основной фреймворк Symfony и его компоненты. В нашем случае используется для групп сериализации.

В среде фреймворка поначалу настраивать ничего не надо, всё работает само, но только в самых простых случаях.

В коде вы можете видеть, что у свйоств сущностей появились аннотации `@Groups` — это группы сериализации.

Группы сериализации и другие настройки контекста
------------------------------------------------

Сериализатор — сложный и многоплановый компонент, который, в свою очередь, содержит в себе другие, не менее сложные компоненты. Сериализатор ображается к декодерам, енкодерам и конвертеру имён при работе, и практически все эти внутренние компоненты доступны для настройки через контекст сериализатора.

К примеру, такой код

```php
$serializedData = $this->serializer->serialize($data, 'json', [
    'groups' => 'index',
    \Symfony\Component\Serializer\Normalizer\AbstractObjectNormalizer::SKIP_NULL_VALUES => true,
]);
```

говорит нормализатору (класс, который конвертирует объект в строку), что нужно конвертировать только те свойства, которые обозначены аннотацией `@Groups({"index"})`, пропускать остальные, а так же пропускать свойства, значениями которых является `null`.

В целом, в контексте сериализации может содержаться значительное количество параметров, которые используются изменения работы приложения или изменения вывода. Стоит посмотреть на то, как работает [Api-Platform](http://api-platform.com/docs/core/), чтобы убедиться.

Циклические ссылки и глубина запроса
------------------------------------

Циклические ссылки это когда объект ссылается сам на себя или же дочерний объект ссылается на родительский, тот на другой дочерний, тот — опять на родительский и так до бесконечности. В примерах кода для избежания подобной ситуации использованы группы сериализации, которые прямо определяют, что свойство дочернего объекта `ReceiptPart::pizza` не должно быть сериализовано в контексте `'groups' => 'index'`. 

Чтобы избежать подобной ситуации без использования групп сериализации, можно объявить функцию (класс), которая будет перехватывать и преобразовывать циклические зависимости:

```php
namespace App\Serializer;

class CircularReferenceHandler
{
    public function __invoke(object $object, string $format = null, array $context = [])
    {
        return \method_exists($object, '__toString') ? (string) $object : \get_class($object);
    }
}
```

и объявить её в настройках сериализатора:

```yaml
framework:
    serializer:
      circular_reference_handler: 'App\Serializer\CircularReferenceHandler'
```

Вы можете воспользоваться магическим методом `__invoke` в классе или же объявить статическую функцию, которая будет указана в настройках. В обоих случаях при обнаружении циклической зависимости она сработает.

Глубина запроса — параметр, отвечающий за то, насколько глубоко по вложенности пройдёт сериализатор. 

Может возникнуть ситуация, когда объект ссылается сам на себя (предположим, вы организуете некую древовидную структуру):

```php
namespace App\Service;

class Tree
{
    private string $title;

    private ?Tree $child;
}
```

Такие объекты, как вы видите, могут вкладываться друг в друга, но если вы попытаетесь такую вложенность сериализовать, вы получите ошибку — фреймворк предостерегает вас от слишком глубокой вложенности, приложение при таком поведении может забрать всю доступную память и упасть.

Есть способ настроить максимальную вложенность — если вы уверены, что большей вложенности не предусмотрено: аннотация `@MaxDepth(n)`, где `n` — уровень. 

Вместо этого или вместе с этим (если мы не знаем потенциальную глубину вложенности), мы можем воспользоваться функцией, превышение максимальной глубины вложенности:

```php
namespace App\Serializer;

class MaxDepthHandler
{
    public function __invoke(object $innerObject, object $outerObject, string $attributeName, string $format = null, array $context = [])
    {
        return '/link/' . $innerObject->getId();
    }
}
```

Объявление в настройках:

```yaml
framework:
    serializer:
      max_depth_handler: 'App\Serializer\MaxDepthHandler'
```

Конвертер имён
--------------

Класс, имплементирующий интерфейс `Symfony\Component\Serializer\NameConverter\NameConverterInterface`, может быть зарегистрирован как конвертер имен для сериализатора. [Официальная документация](https://symfony.com/doc/current/components/serializer.html#component-serializer-converting-property-names-when-serializing-and-deserializing) приводит достаточно прозрачный пример, кроме того, существует [встроенный](https://symfony.com/doc/current/serializer.html#enabling-a-name-converter) `camel_case_to_snake_case`-конвертер — как несложно догадаться, он переводит CamelCase написание свойств в snack_case.

Стоит добавить, что конвертер имен может использоваться не только для изменения названий свойств класса, но и в обратном направлении — для конвертации названий полей API-запроса в имена класса. Это особенно пригождается, когда вы получаете JSON-запросы, поля которых не соответствуют ни вашим классам, ни именам полей в них.

Документирование, внешние фреймворки
------------------------------------

Для того, чтобы ваше приложение могло взаимодействовать с внешними системами, эти системы (и их разработчики) должны знать, как это делать. И если в случае с традиционными приложениями вы показываете данные так, как решитте самостоятельно, а принимаете их через формы (получается заранее определенный формат), то какое-нибудь мобильное приложение, взаимодействующее с вашим API (и программист, который это приложение делает), ничего не знает ни о том, что вы ему отдаёте, ни о том, какие данные вы от него ждёте. Зачастую, даже исходный код вашего API недоступен для мобильных разработчиков, и практически в 100% случаев — непонятен.

Собственно, для этого придумана документация, причем не просто в виде текста, а в виде формализованных данных.

Стандартная модель — [OpenApi / Swagger](http://swagger.io), со своими Javascript UI, показывает доступные для разработчика методы, свойства и форматы данных. Более того, JSON-документация, сформированная по OpenAPI-стандарту, машиночитаема, то есть формализована так, что из неё можно генерировать код, интерфейсы и прочее.

Библиотека, которая предоставляет возможность генерировать такую документацию — [NelmioApiDocBundle](https://symfony.com/doc/current/bundles/NelmioApiDocBundle/index.html), читает специальные аннотации контроллеров и формирует из них [Swagger UI](https://swagger.io/tools/swagger-ui/).

Для комплексного подхода к разработке API-приложений стоит обратить внимание на [Api-Platform](http://api-platform.com) — по-настоящему мощный фреймворк поверх Symfony, который предоставляет множество возможностей из коробки. К примеру, CRUD-операции включаются одной аннотацией Doctrine-сущности — `@ApiResource`.

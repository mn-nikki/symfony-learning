HttpFoundation
==============

Как нам известно, php-приложение в традиционном его понимании начинается с http-запроса и заканчивается http-ответом.

Напомню, http-обмен, если его воспринимать в виде текста, выглядит примерно так

```
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#0)
> GET /get?foo=bar HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.64.1
> Accept: */*
>
< HTTP/1.1 200 OK
< Server: gunicorn/19.9.0
< Date: Fri, 05 Jun 2020 07:02:01 GMT
< Connection: keep-alive
< Content-Type: application/json
< Content-Length: 217
< Access-Control-Allow-Origin: *
< Access-Control-Allow-Credentials: true
<
* Excess found in a non pipelined read: excess = 217 url = /get (zero-length body)
* Connection #0 to host localhost left intact
* Closing connection 0
```

Кроме того, что мы видим, внутри http-запроса существуют (или могут существовать):

- параметры (переменные) веб-сервера;
- cookies;
- файлы;
- информация о перенаправлениях или прокси-серверах;
- контент (body) запроса (когда пользователь отправляет данные без формы);

Логично, что для того, чтоб со всем этим работать, следует иметь объект, в котором и хранить все данные запроса, получать и при необходимости обрабатывать их.

Для этого Symfony-фреймворк предоставляет класс [Request](https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/Request.php).

Давайте посмотрим, как он работает
----------------------------------

Откройте файл `public/index.php` и найдите в нём строку `$request = Request::createFromGlobals();`. Именно эта строка формирует объект запроса, с которым мы дальше работаем.

Там же содержится и ответ на вопрос, заданный в теме урока — «Как запрос попадает в ядро». Метод `handle` принимает запрос и возвращает ответ, ничего сложного :) Об этом, однако, чуть позже, пока что остановимся на формировании запроса как такового.

Symfony\Component\HttpFoundation\Request
----------------------------------------

Все свойства запроса:

- `request` — эквивалент `$_POST`;
- `query` — эквивалент `$_GET`;
- `attributes` — «кастомные» параметры. Это свойство используется непосредственно фреймворком и содержит служебную информацию, которая будет очень полезна при разработке. В частности, именно в этом свойстве сохраняется информация о контроллере и действии контроллера, которые будут обрабатывать этот запрос, локаль приложения (если назначена) и другие параметры;
- `cookies` — эквивалент `$_COOKIES`;
- `files` — эквивалент `$_FILES`;
- `server` — эквивалент `$_SERVER`, все параметры, которые передал веб-сервер. В частности, информация о кодировке, формате, агенте и протоколе, а так же другие параметры, переданные сервером;
- `headers` — заголовки запроса. 

Все эти свойства после инициализации (то есть, в нашем случае, создания запроса с `Request::createFromGlobals()`) становятся экземплярами одного типа — [ParameterBag](https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpFoundation/ParameterBag.php), или дочерних, расширяющих его, типов. Этот класс имеет методы для доступа к данным и их обработки:

- `all()` — возвращает весь массив параметров;
- `keys()` — ключи массива (только ключи post-запроса, например);
- `replace(array $inputs = [])` — заменяет весь массив параметров на новый;
- `add(array $inputs = [])` — добавляет параметры;
- `get(string $key, $default = null)` — получает параметр по имени. Обратите внимание, что вторым параметром может быть значение по-умолчанию, на случай, если ваш ключ не найден; 
- `set(string $key, $value)` — устанавлиает значение
- `has(string $key)` — проверяет существование ключа.

Итак, объект класса Request сформирован на самом раннем этапе существования приложения. Этот объект позволяет получить всё, что есть в http-запросе, и не использовать суперглобальные переменные для этого. 

Symfony\Component\HttpKernel\Kernel
-----------------------------------

Ядро — это где приложение **действует**. В комментариях к классу написано «The Kernel is the heart of the Symfony system». Два главных действия, которые происходят при загрузке ядра — инициализация _бандлов_ (обособленная часть приложения, которая предназначена для выполнения некоего законченного комплекса действий) и _контейнера зависимостей_. 

Каждый бандл — маленькое приложение определенной структуры, которое получает контейнер и может взаимодействовать с другоми приложениями.

Контейнер зависимостей реализует паттерн Inversion of Control и является центральной «точкой обмена» на протяжении всей работы приложения: он содержит предварительно настроенные экземпляры всех классов, которые объявлены, как сервисы, и позволяет сервисам обращаться друг к другу.

Концепцию сервисов и их взаимодействия мы будем подробно рассматривать позже, сейчас посмотрим, что происходит дальше.

Symfony\Component\HttpFoundation\Response
-----------------------------------------

Созданное в `index.php` ядро получает в метод `handle` экземпляр класса Request, и возвращает экземпляр класса Response. Response — ещё один ключевой элемент фреймворка и веба в целом — любой клиентский браузер отправляет запросы и получает ответы, и Response интерпретируется в итоге именно как ответ для браузера — комплект заголовков, cookie-файлов и в общем итоге, текст ответа. В традиционном подходе «текст» — это html, который уже сам браузер превращает в веб-страницу, но мы не ограничены только html-ом, конечно: ответом может быть json-строка, XML-документ, бинарная строка, которая превращается в файл или что угодно вообще.

В процессе формирования ответ может пройти через несколько ваших сервисов и быть измененным в зависимости от обстоятельств — к примеру, получить дополнительные заголовки (или же сервис может удалять какие-то заголовки, если они в данных обстоятельствах не нужны), cookie-файлы, изменить статус или получить какое-то дополнение к телу ответа.

Поскольку Response — это объект (а все объекты в php всегда передаются по ссылке), мы имеем практически неограниченные возможности для формирования и последующего изменения нашего ответа.

Объект Response (и его зависимые объекты) включает в себя множество вспомогательных функций, которые позволяют лаконично формировать нужные ответы и устанавливать нужные свойства.

К примеру:

- `$response->headers->setCookie(Cookie::create('name', 'value'));` — устанавливает для клиента cookie-файл `name` со значением `value`;
- `$response->setCache(['must_revalidate' => false, 'no_cache' => true])` — устанавливает разнообразные параметры http-кэширования;
- Простой способ создать ответ с редиректом — отправить `new RedirectResponse('http://google.com/');`. Это автоматически устанавливает заголовок 304 для ответа и браузер клиента уходит по назначенному адресу;
- Отправка файла: 
    ```php
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpFoundation\HeaderUtils;
    
    $content = \file_get_contents('/path/to/file');
    $response = (new Response())->setContent($content);
    $disposition = HeaderUtils::makeDisposition(HeaderUtils::DISPOSITION_ATTACHMENT, 'filename.pdf');
    $response->headers->set('Content-Disposition', $disposition);
    ```
- Отправка JSON-ответа: `new JsonResponse(['result' => 1024]);`

В конце концов, когда сам объект ответа сформирован, нам нужно его отправить. Непосредственно отправка служебной информации (заголовков) и тела ответа работает на уровне языка: 

- метод `sendHeaders` класса Response вызывает php-функицю `header` для каждого установленного заголовка, 
- и метод `sendContent` просто выводит (echo) тело ответа.

Заключение
----------

- Symfony-приложение имеет единую «точку входа» — файл `public/index.php`;
- Веб-сервер запускает этот файл через интерпретатор php;
- В этом файле http-запрос преобразуется в объект `Symfony\Component\HttpFoundation\Request`;
- Созданное здесь же ядро приложения получает этот запрос для обработки;
- В результате этой обработки возвращается объект `Symfony\Component\HttpFoundation\Response`;
- Который с помощью собственных методов отправляет клиенту ответ, включая заголовки и тело.

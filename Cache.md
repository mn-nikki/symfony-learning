Кэширование внутренних данных
=============================

[Статья официальной документации](https://symfony.com/doc/current/cache.html)     
[Cache-компонент](https://symfony.com/doc/current/components/cache.html)

Использование кэширования — хороший способ сделать приложение быстрее. Естественно, для хранения кэшированных данных нужна некая внешняя система (key-value storage), хотя в самых простых случаях можно обойтись и просто файловой системой хоста. Для продакшн-окружений обычно используется одно из следующих решений:

- [APCu](https://www.php.net/apcu) — хранилище кэша в памяти хоста. Самый простой случай и довольно ограниченная функциональность;
- [Memcached](https://memcached.org) — также хранилище в памяти, но с более расширенной функциональностью. В частности, предоставляет возможность http-запросов, а memcached-серверы могут быть объединены в кластер;
- [PDO](https://www.php.net/manual/en/pdo.drivers.php) — для хранения кэшированных данных может использоваться любая БД, к которой существует PDO-драйвер. Естественно, нет смысла использовать для кэширования ту же самую БД, что является основной для приложения, но какую-то отдельную базу данных с высокими показателями скорости — вполне приемлемо;
- [Redis](https://redis.io) — key-value хранилище, хранит данные в памяти и с некоторой периодичностью сбрасывает их на диск. Может использоваться не только как кэш, но и как брокер очередей, обладает очень хорошей скоростю доступа к данным, предоставляет доступ по http, серверы могут быть объединены в кластер.

Кэш-компонент и адаптеры
------------------------

Сам по себе кэш-компонент устанавливается стандартным путём:

```shell
composer require symfony/cache
```

Вместе с компонентом устанавливаются и адаптеры, и если в приложении не планируется использовать какой-то нестандартный адаптер для доступа к кэшу, их достаточно. 

Следует различать использование кэша на уровне фреймворка и отдельное обращение к элементам, сохраненным в хранилище. На уровне фреймворка всё использование заключается только в настройке, специально внутри кода не нужно делать ничего больше, всё работает само.

### Настройка кэш-компонента

Предположим, Redis выбран основным хранилищем кэша для нашего приложения. Встроенный адаптер (`Symfony\Component\Cache\Adapter\RedisAdapter`) позволяет не использовать сторонние компоненты для соединения с Redis-сервером, в нём есть возможность установки соединения с использованием расширения php [redis](https://pecl.php.net/package/redis), а значит, мы можем определить хранилище кэша приложения не устанавливая больше ничего.

Конфигурация сервиса:

```yaml
services:
  app.cache.redis_provider:
    class: Redis
    factory: ['Symfony\Component\Cache\Adapter\RedisAdapter', 'createConnection']
    arguments:
      - '%env(REDIS_DSN)%'
```

Конфигурация фреймворка (`config/packages/cache.yaml`):

```yaml
framework:
  cache:
    prefix_seed: creative/symfony_learning
    default_redis_provider: app.cache.redis_provider
    app: cache.adapter.redis
    system: cache.adapter.redis
```

Обратите внимание на настройку пулов: это отдельные сервисы для раздельного обращения к ним, и раздельного использования. Эти сервисы создаются динамически, и в итоге используют те провайдеры, которые указаны уровнем выше.

Непосредственная работа с кэшем
-------------------------------

Временами бывает нужно непосредственно записать в кэш (и прочитать из кэша) некие данные. Это очень помогает, если вы, к примеру, выполняете http-запросы к некоему сервису, данные в котором меняются нечасто. Чтобы каждый раз не запрашивать этот сервис, можно отправить его ответ в кэш на период его обновления, и читать потом оттуда.

Symfony предоставляет собственный способ работы с кэшем для таких случаев: в `Symfony\Contracts\Cache\CacheInterface` есть только методы `get` и `delete`, и `get` получает ID записи кэша и функцию, которая выполняет работу по получению настоящих данных.

Идея в том, что если запись с таким ID существует, то функция не выполняется и просто возвращается значение этой записи, а если же нет — то выполняется функция и возвращается то, что вернула она

